"use strict";(self.webpackChunkzell_chaos=self.webpackChunkzell_chaos||[]).push([[7908],{8983:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var a=t(85893),n=t(11151);const i={layout:"posts",title:"Recursive call activity",date:new Date("2023-02-23T00:00:00.000Z"),categories:["chaos_experiment","bpmn"],tags:["availability"],authors:"zell"},r="Chaos Day Summary",o={permalink:"/zeebe-chaos/2023/02/23/Recursive-call-activity",editUrl:"https://github.com/zeebe-io/zeebe-chaos/blob/master/chaos-days/blog/2023-02-23-Recursive-call-activity/index.md",source:"@site/blog/2023-02-23-Recursive-call-activity/index.md",title:"Recursive call activity",description:"Long time no see. Happy to do my first chaos day this year. In the last week have implemented interesting features, which I would like to experiment with.",date:"2023-02-23T00:00:00.000Z",formattedDate:"February 23, 2023",tags:[{label:"availability",permalink:"/zeebe-chaos/tags/availability"}],readingTime:4.03,hasTruncateMarker:!0,authors:[{name:"Christopher Kujawa",title:"Chaos Engineer @ Zeebe",url:"https://github.com/zelldon",imageURL:"https://github.com/zelldon.png",key:"zell"}],frontMatter:{layout:"posts",title:"Recursive call activity",date:"2023-02-23T00:00:00.000Z",categories:["chaos_experiment","bpmn"],tags:["availability"],authors:"zell"},unlisted:!1,prevItem:{title:"Gateway Termination",permalink:"/zeebe-chaos/2023/04/06/gateway-termination"},nextItem:{title:"Message Correlation after Network Partition",permalink:"/zeebe-chaos/2022/08/31/Message-Correlation-after-Network-Partition"}},c={authorsImageUrls:[void 0]},l=[{value:"Chaos Experiment",id:"chaos-experiment",level:2},{value:"Expected",id:"expected",level:3},{value:"Actual",id:"actual",level:3},{value:"Found Bugs",id:"found-bugs",level:2}];function h(e){const s={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(s.p,{children:["Long time no see. Happy to do my first chaos day this year. In the last week have implemented interesting features, which I would like to experiment with.\n",(0,a.jsx)(s.a,{href:"https://github.com/camunda/zeebe/issues/11416",children:"Batch processing"})," was one of them."]}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.strong,{children:"TL;DR;"})," Chaos experiment failed. ","\ud83d\udca5"," Batch processing doesn't seem to respect the configured limit, which causes issues with processing and influences the health of the system. We found a bug ","\ud83d\udcaa"]}),"\n",(0,a.jsx)(s.h2,{id:"chaos-experiment",children:"Chaos Experiment"}),"\n",(0,a.jsxs)(s.p,{children:["In today's chaos experiment, we want to experiment with ",(0,a.jsx)(s.a,{href:"https://github.com/camunda/zeebe/issues/11416",children:"Batch processing"})," and how it can handle error conditions, like deploying an endless recursive process model."]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.img,{alt:"recursive process",src:t(21917).Z+"",width:"903",height:"276"})}),"\n",(0,a.jsx)(s.h3,{id:"expected",children:"Expected"}),"\n",(0,a.jsxs)(s.p,{children:["When we deploy such a process model and create an instance of it, we expect that the execution is done endlessly. In normal process models with batch processing, the execution of a process instance is done until a wait state is reached. In this process model, there exists no wait state. To handle such cases, we have implemented a batch limit, which can be configured via ",(0,a.jsx)(s.a,{href:"https://github.com/camunda/zeebe/blob/main/dist/src/main/config/broker.standalone.yaml.template#L695",children:"maxCommandsInBatch"}),". This configuration is by default set to 100 commands. Meaning the stream processor will process 100 commands until it stops, to make room for other things."]}),"\n",(0,a.jsx)(s.p,{children:"We expect that our limit handling steps in during the execution and we can execute also other instances or, cancel the problematic process instance. Furthermore, we expect to stay healthy, we should be able to update our health check continuously."}),"\n",(0,a.jsx)(s.h3,{id:"actual",children:"Actual"}),"\n",(0,a.jsxs)(s.p,{children:["Before we can start with our experiment we need to start our benchmark Zeebe cluster. This has become easier now since I have written the last post. Previously we had to use the scripts and Makefile in the ",(0,a.jsx)(s.a,{href:"https://github.com/camunda/zeebe/tree/main/benchmarks/setup",children:"zeebe/benchmark sub-directory"}),"."]}),"\n",(0,a.jsxs)(s.p,{children:["We have now provided new ",(0,a.jsx)(s.a,{href:"https://github.com/zeebe-io/benchmark-helm",children:"Benchmark Helm charts"}),", based on our Camunda Platform Helm charts. They allow us to deploy a new zeebe benchmark setup via:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-shell",children:"kubectl create namespace zell-chaos # create a new namespace\nkubens zell-chaos  # change context to a new namespace\n# deploy zeebe benchmark cluster - without starter and worker\nhelm install zell-chaos \\\n    zeebe-benchmark/zeebe-benchmark \\\n    --set starter.replicas=0 \\\n    --set worker.replicas=0\n"})}),"\n",(0,a.jsxs)(s.p,{children:["To deploy the model we can use ",(0,a.jsx)(s.a,{href:"https://github.com/zeebe-io/zeebe-chaos/releases/tag/zbchaos-v1.0.0",children:"zbchaos v1.0.0"}),"."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-shell",children:"$ zbchaos deploy process --processModelPath call.bpmn \n{1 LEADER -1 call.bpmn 10  msg false 1 LEADER -1 2 LEADER -1 1677157340943 false false true false false 30 false -1 benchmark 30  }\nDeployed given process model call.bpmn, under key 2251799813685249!\n"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"Note: Looks like we have some left-over debug logs, which we should remove."})}),"\n",(0,a.jsx)(s.p,{children:"To create an instance we can use:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-shell",children:"$ zbchaos verify instance-creation --bpmnProcessId super\n{1 LEADER -1  10  msg false 1 LEADER -1 2 LEADER -1 1677157569058 false false true false false 30 false -1 super 30  }\nThe steady state was successfully verified!\n"})}),"\n",(0,a.jsxs)(s.p,{children:["After creating the instance we can observe the behavior of the Zeebe via ",(0,a.jsx)(s.a,{href:"https://grafana.dev.zeebe.io/",children:"grafana"}),"."]}),"\n",(0,a.jsx)(s.p,{children:"We can see that the processing starts immediately quite high and is continuously going on."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.img,{alt:"general",src:t(51940).Z+"",width:"1842",height:"421"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"We have two instances running, one on partition three and one on partition one."})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsxs)(s.em,{children:["One interesting fact is that the topology request rate is also up to 0.400 per second, so potentially every 2.5 seconds we send a topology request to the gateway. But there is no application deployed that does this. ",(0,a.jsx)(s.a,{href:"https://github.com/camunda/zeebe/pull/11599#discussion_r1109846523",children:"I have recently found out again"}),", that we have the Zeebe client usage in the gateway to request the topology. Might be worth investigating whether this is an issue."]})}),"\n",(0,a.jsx)(s.p,{children:"After observing this cluster for a while we can see that after around five minutes the cluster fails. The processing for the partitions breaks down to 1/10 of what was processed before. A bit later it looks like it tries to come back but, failed again."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.img,{alt:"fail-general",src:t(1399).Z+"",width:"1853",height:"975"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"We can see in the metrics that in between also the balancing was triggered. A feature we have as part of our Benchmark Helm charts."})}),"\n",(0,a.jsxs)(s.p,{children:["The logs (at stack driver) doesn't give us many insights, ",(0,a.jsx)(s.a,{href:"https://console.cloud.google.com/logs/query;query=resource.type%3D%22k8s_container%22%0Aresource.labels.project_id%3D%22zeebe-io%22%0Aresource.labels.location%3D%22europe-west1-b%22%0Aresource.labels.cluster_name%3D%22zeebe-cluster%22%0Aresource.labels.namespace_name%3D%22zell-chaos%22%0Alabels.k8s-pod%2Fapp%3D%22camunda-platform%22%0Alabels.k8s-pod%2Fapp_kubernetes_io%2Fcomponent%3D%22zeebe-broker%22%0Alabels.k8s-pod%2Fapp_kubernetes_io%2Finstance%3D%22zell-chaos%22%0Alabels.k8s-pod%2Fapp_kubernetes_io%2Fmanaged-by%3D%22Helm%22%0Alabels.k8s-pod%2Fapp_kubernetes_io%2Fname%3D%22zeebe%22%0Alabels.k8s-pod%2Fapp_kubernetes_io%2Fpart-of%3D%22camunda-platform%22;timeRange=2023-02-23T12:17:49.128812Z%2F2023-02-23T14:18:59.101Z;pinnedLogId=2023-02-23T13:13:40.945376476Z%2Fdr4gxdklsxtgx6h6;cursorTimestamp=2023-02-23T13:13:40.945376476Z?project=zeebe-io",children:"except that we see that nodes becoming unhealthy"}),". Similar information we can see in the metrics, that followers are unhealthy."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-shell",children:"Partition-1 failed, marking it as unhealthy: Broker-2{status=HEALTHY}\nDetected 'UNHEALTHY' components. The current health status of components: [Partition-2{status=HEALTHY}, Partition-1{status=UNHEALTHY, issue=HealthIssue[message=null, throwable=null, cause=Broker-2-StreamProcessor-1{status=UNHEALTHY, issue=HealthIssue[message=actor appears blocked, throwable=null, cause=null]}]}, Partition-3{status=HEALTHY}]\n"})}),"\n",(0,a.jsx)(s.p,{children:"Interesting insights we can get in our new Batch processing metrics. We see that at the beginning we use our limit of 100 commands per batch, but soon as we start with the recursion we use an enormous high batch processing command count."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.img,{alt:"fail-batchprocessing.png",src:t(26354).Z+"",width:"1829",height:"552"})}),"\n",(0,a.jsx)(s.p,{children:"The new sequence metric shows similar results, so there must be a problem with not respecting the limit."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.img,{alt:"sequencer",src:t(25020).Z+"",width:"1855",height:"513"})}),"\n",(0,a.jsxs)(s.p,{children:["With this, I mark this chaos experiment as failed. We need to investigate this further and fix the related issue.","\ud83d\udca5"]}),"\n",(0,a.jsx)(s.h2,{id:"found-bugs",children:"Found Bugs"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:(0,a.jsx)(s.a,{href:"https://github.com/zeebe-io/zeebe-chaos/issues/323",children:"zbchaos logs debug message on normal usage"})}),"\n",(0,a.jsx)(s.li,{children:(0,a.jsx)(s.a,{href:"https://github.com/camunda/zeebe/issues/11799",children:"Every 2.5 seconds we send a topology request, which is shown in the metrics"})}),"\n",(0,a.jsx)(s.li,{children:(0,a.jsx)(s.a,{href:"https://github.com/camunda/zeebe/issues/11798",children:"Batch processing doesn't respect the limit"})}),"\n"]})]})}function d(e={}){const{wrapper:s}={...(0,n.a)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},21917:(e,s,t)=>{t.d(s,{Z:()=>a});const a=t.p+"assets/images/call-8d5375c7dcbd4d2e36d20706dd178d3d.png"},26354:(e,s,t)=>{t.d(s,{Z:()=>a});const a=t.p+"assets/images/fail-batchprocessing-1db16026a70bf497036fdaf1df98bf26.png"},1399:(e,s,t)=>{t.d(s,{Z:()=>a});const a=t.p+"assets/images/fail-general-7f21e7fd29654bb0b4bac784a956c203.png"},51940:(e,s,t)=>{t.d(s,{Z:()=>a});const a=t.p+"assets/images/general-96c61dbea3faf18172737f97412ce400.png"},25020:(e,s,t)=>{t.d(s,{Z:()=>a});const a=t.p+"assets/images/sequencer-e1680cd2da0acc84faf51d494411962b.png"},11151:(e,s,t)=>{t.d(s,{Z:()=>o,a:()=>r});var a=t(67294);const n={},i=a.createContext(n);function r(e){const s=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),a.createElement(i.Provider,{value:s},e.children)}}}]);