"use strict";(self.webpackChunkzell_chaos=self.webpackChunkzell_chaos||[]).push([[5921],{31626:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var o=t(85893),i=t(11151);const r={layout:"posts",title:"Automating Deployment Distribution Chaos Experiment",date:new Date("2021-02-23T00:00:00.000Z"),categories:["chaos_experiment","broker","network","deployment"],tags:["tests"],authors:"zell"},s="Chaos Day Summary",a={permalink:"/zeebe-chaos/2021/02/23/automate-deployments-dist",editUrl:"https://github.com/zeebe-io/zeebe-chaos/blob/master/chaos-days/blog/2021-02-23-automate-deployments-dist/index.md",source:"@site/blog/2021-02-23-automate-deployments-dist/index.md",title:"Automating Deployment Distribution Chaos Experiment",description:"This time I wanted to automate a chaos experiment via the ChaosToolkit, which I did on the last chaos day. For a recap check out the last chaos day summary.",date:"2021-02-23T00:00:00.000Z",formattedDate:"February 23, 2021",tags:[{label:"tests",permalink:"/zeebe-chaos/tags/tests"}],readingTime:6.855,hasTruncateMarker:!0,authors:[{name:"Christopher Zell",title:"Chaos Engineer @ Zeebe",url:"https://github.com/zelldon",imageURL:"https://github.com/zelldon.png",key:"zell"}],frontMatter:{layout:"posts",title:"Automating Deployment Distribution Chaos Experiment",date:"2021-02-23T00:00:00.000Z",categories:["chaos_experiment","broker","network","deployment"],tags:["tests"],authors:"zell"},unlisted:!1,prevItem:{title:"Fault-tolerant processing of process instances",permalink:"/zeebe-chaos/2021/03/09/cont-workflow-instance"},nextItem:{title:"Deployment Distribution",permalink:"/zeebe-chaos/2021/01/26/deployments"}},l={authorsImageUrls:[void 0]},c=[{value:"Chaos Experiment",id:"chaos-experiment",level:2},{value:"Expected",id:"expected",level:3},{value:"Experiment Definition",id:"experiment-definition",level:3},{value:"Create network partition between leaders",id:"create-network-partition-between-leaders",level:4},{value:"Delete network partition",id:"delete-network-partition",level:4},{value:"Deploy different deployment versions",id:"deploy-different-deployment-versions",level:5},{value:"Create workflow instance of latest version on partition X",id:"create-workflow-instance-of-latest-version-on-partition-x",level:4},{value:"Outcome",id:"outcome",level:3},{value:"Testbench",id:"testbench",level:4}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["This time I wanted to automate a chaos experiment via the ",(0,o.jsx)(n.a,{href:"https://chaostoolkit.org/",children:"ChaosToolkit"}),", which I did on the last chaos day. For a recap check out the ",(0,o.jsx)(n.a,{href:"/zeebe-chaos/2021/01/26/deployments",children:"last chaos day summary"}),"."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"TL;DR;"})}),"\n",(0,o.jsxs)(n.p,{children:["I was able to automate the deployment distribution chaos experiment successfully and deployed it on testbench for a ",(0,o.jsx)(n.code,{children:"Production - M"})," cluster plan."]}),"\n",(0,o.jsx)(n.h2,{id:"chaos-experiment",children:"Chaos Experiment"}),"\n",(0,o.jsx)(n.p,{children:"For testing, I have run our normal setup of three nodes, three partitions and replication factor three.\nLater I wanted to automate the experiment against the production cluster plans."}),"\n",(0,o.jsx)(n.h3,{id:"expected",children:"Expected"}),"\n",(0,o.jsx)(n.p,{children:"We want to verify whether deployments are still distributed after a network partition, for that we will write the following chaos experiment:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Verify Steady State: All Pods are ready"}),"\n",(0,o.jsxs)(n.li,{children:["Introduce Chaos:","\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Action:"})," Disconnect two leaders (Leader of partition one and another leader)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Action:"})," Deploy multiple versions of a workflow"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Action:"})," Connect two leaders again"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.em,{children:"Probe"}),": I can create workflow instance on all partitions with the last workflow version"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"Verify Steady State: All Pods are ready"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"experiment-definition",children:"Experiment Definition"}),"\n",(0,o.jsx)(n.p,{children:"The experiment definition looks like the following:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\n    "version": "0.1.0",\n    "title": "Zeebe deployment distribution",\n    "description": "Zeebe deployment distribution should be fault-tolerant. Zeebe should be able to handle network outages and fail-overs and distribute the deployments after partitions are available again.",\n    "contributions": {\n        "reliability": "high",\n        "availability": "high"\n    },\n    "steady-state-hypothesis": {\n        "title": "Zeebe is alive",\n        "probes": [\n            {\n                "name": "All pods should be ready",\n                "type": "probe",\n                "tolerance": 0,\n                "provider": {\n                    "type": "process",\n                    "path": "verify-readiness.sh",\n                    "timeout": 900\n                }\n            }\n        ]\n    },\n    "method": [\n        {\n            "type": "action",\n            "name": "Create network partition between leaders",\n            "provider": {\n                "type": "process",\n                "path": "disconnect-leaders.sh"\n            }\n        },\n        {\n            "type": "action",\n            "name": "Deploy different deployment versions.",\n            "provider": {\n                "type": "process",\n                "path": "deploy-different-versions.sh",\n                "arguments": ["Follower", "3"]\n            }\n        },\n        {\n            "type": "action",\n            "name": "Delete network partition",\n            "provider": {\n                "type": "process",\n                "path": "connect-leaders.sh"\n            }\n        },\n        {\n            "type": "probe",\n            "name": "Create workflow instance of latest version on partition one",\n            "tolerance": 0,\n            "provider": {\n                "type": "process",\n                "path": "start-instance-on-partition-with-version.sh",\n                "arguments": ["1", "10"],\n                "timeout": 900\n            }\n        },\n        {\n            "type": "probe",\n            "name": "Create workflow instance of latest version on partition two",\n            "tolerance": 0,\n            "provider": {\n                "type": "process",\n                "path": "start-instance-on-partition-with-version.sh",\n                "arguments": ["2", "10"],\n                "timeout": 900\n            }\n        },\n        {\n            "type": "probe",\n            "name": "Create workflow instance of latest version on partition three",\n            "tolerance": 0,\n            "provider": {\n                "type": "process",\n                "path": "start-instance-on-partition-with-version.sh",\n                "arguments": ["3", "10"],\n                "timeout": 900\n            }\n        }\n    ],\n    "rollbacks": []\n}\n'})}),"\n",(0,o.jsx)(n.h4,{id:"create-network-partition-between-leaders",children:"Create network partition between leaders"}),"\n",(0,o.jsx)(n.p,{children:"We reuse a script which we introduce in earlier chaos days. It needed to be improved a bit, since we haven't handled clusters where one node leads multiple partitions."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:'#!/bin/bash\nset -exuo pipefail\n\nsource utils.sh\n\npartition=1\nnamespace=$(getNamespace)\ngateway=$(getGateway)\n\n# determine leader for partition one\nindex=$(getIndexOfPodForPartitionInState "$partition" "LEADER")\nleader=$(getBroker "$index")\nleaderIp=$(kubectl get pod "$leader" -n "$namespace" --template="{{.status.podIP}}")\n\n# determine leader for partition three\nindex=$(getIndexOfPodForPartitionInState "3" "LEADER")\nleaderTwo=$(getBroker "$index")\nleaderTwoIp=$(kubectl get pod "$leaderTwo" -n "$namespace" --template="{{.status.podIP}}")\n\nif [ "$leaderTwo" == "$leader" ]\nthen\n  # determine leader for partition two\n  index=$(getIndexOfPodForPartitionInState "2" "LEADER")\n  leaderTwo=$(getBroker "$index")\n  leaderTwoIp=$(kubectl get pod "$leaderTwo" -n "$namespace" --template="{{.status.podIP}}")\n\n  if [ "$leaderTwo" == "$leader" ]\n  then\n    # We could try to kill the pod and hope that he is not able to become leader again,\n    # but there is a high chance that it is able to do so after restart. It can make our test fragile,\n    # especially if we want to connect again, which is the reason why we do nothing in that case.\n    exit\n  fi\nfi\n\n# To print the topology in the journal\nretryUntilSuccess kubectl exec "$gateway" -n "$namespace" -- zbctl status --insecure\n\n# we put all into one function because we need to make sure that even after preemption the \n# dependency is installed\nfunction disconnect() {\n toChangedPod="$1"\n targetIp="$2"\n\n # update to have access to ip\n kubectl exec -n "$namespace" "$toChangedPod" -- apt update\n kubectl exec -n "$namespace" "$toChangedPod" -- apt install -y iproute2\n kubectl exec "$toChangedPod" -n "$namespace" -- ip route add unreachable "$targetIp"\n\n}\n\nretryUntilSuccess disconnect "$leader" "$leaderTwoIp"\nretryUntilSuccess disconnect "$leaderTwo" "$leaderIp" \n'})}),"\n",(0,o.jsx)(n.h4,{id:"delete-network-partition",children:"Delete network partition"}),"\n",(0,o.jsx)(n.p,{children:"Looks similar to the disconnect script."}),"\n",(0,o.jsx)(n.h5,{id:"deploy-different-deployment-versions",children:"Deploy different deployment versions"}),"\n",(0,o.jsxs)(n.p,{children:["This script is interesting. My first approach was to have one workflow model, where I replace an comment via ",(0,o.jsx)(n.code,{children:"sed"})," before redeploying. Later I realized it is much easier to just have two versions of the same worfklow model in the repository and deploy them in an alternating manner. This reduced the dependecy of an extra tool (",(0,o.jsx)(n.code,{children:"sed"}),"), which might not be available everywhere or work differently on different linux distributions."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:'#!/bin/bash\n\nset -exuo pipefail\n\nscriptPath=$( cd "$(dirname "${BASH_SOURCE[0]}")" ; pwd -P )\nsource utils.sh\n\nnamespace=$(getNamespace)\npod=$(getGateway)\n\nbpmnPath="$scriptPath/../bpmn/"\n\n# we put both together in one function to retry both, because it might be that pod has been restarted\n# then the model is not longer on the node, which cause endless retries of deployments\nfunction deployModel() {\n  kubectl cp "$bpmnPath" "$pod:/tmp/" -n "$namespace"\n\n  for i in {1..5}\n  do\n    # the models differ in one line, the share the same name and process id\n    # if we deploy them after another it will create two different deployment versions\n    # the deploy command only compares the last applied deployment - so we can do that in a loop to cause\n    # multiple deployments\n    kubectl exec "$pod" -n "$namespace" -- sh -c "zbctl deploy /tmp/bpmn/multi-version/multiVersionModel.bpmn --insecure"\n    kubectl exec "$pod" -n "$namespace" -- sh -c "zbctl deploy /tmp/bpmn/multi-version/multiVersionModel_v2.bpmn --insecure"\n  done\n}\n\nretryUntilSuccess deployModel\n'})}),"\n",(0,o.jsxs)(n.p,{children:["When running this script we deploy ",(0,o.jsx)(n.code,{children:"10"})," new versions of the workflow ",(0,o.jsx)(n.code,{children:"multiVersion"}),"."]}),"\n",(0,o.jsx)(n.h4,{id:"create-workflow-instance-of-latest-version-on-partition-x",children:"Create workflow instance of latest version on partition X"}),"\n",(0,o.jsxs)(n.p,{children:["The following script allows us to be sure that we can create a workflow instance on a specific partition with the given version of the ",(0,o.jsx)(n.code,{children:"multiVersion"})," workflow.\nThis means we can verify that on all partitions the last deployment version is deployed/distributed."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:'#!/bin/bash\nset -xo pipefail\n\nif [ -z "$1" ]\nthen\n  echo "Please provide an required partition!"\n  exit 1\nfi\n\nif [ -z "$2" ]\nthen\n  echo "Please provide an required deployment version!"\n  exit 1\nfi\n\nsource utils.sh\n\nnamespace=$(getNamespace)\npod=$(getGateway)\n\nrequiredPartition=$1\nrequiredDeploymentVersion=$2\nprocessId="multiVersion"\n\n# we put all into one function because we need to make sure that even after preemption the\n# dependency are installed, which is in this case is the deployment\nfunction startInstancesOnPartition() {\n\n  partition=0\n  until [[ "$partition" -eq "$requiredPartition" ]]; do\n    workflowInstanceKey=$(kubectl exec "$pod" -n "$namespace" -- zbctl create instance "$processId" --version "$requiredDeploymentVersion" --insecure)\n    workflowInstanceKey=$(echo "$workflowInstanceKey" | jq \'.workflowInstanceKey\')\n    partition=$(( workflowInstanceKey >> 51 ))\n    echo "Started workflow with key $workflowInstanceKey, corresponding partition $partition"\n  done\n}\n\nretryUntilSuccess startInstancesOnPartition\n'})}),"\n",(0,o.jsx)(n.h3,{id:"outcome",children:"Outcome"}),"\n",(0,o.jsxs)(n.p,{children:["After running this experiment we get the following output, which shows us that the experiment ",(0,o.jsx)(n.strong,{children:"SUCCEEDED"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"(chaostk) [zell camunda-cloud/ cluster: zeebe-cluster ns:zell-chaos]$ chaos run production-m/deployment-distribution/experiment.json \n[2021-02-23 14:15:06 INFO] Validating the experiment's syntax\n[2021-02-23 14:15:06 INFO] Experiment looks valid\n[2021-02-23 14:15:06 INFO] Running experiment: Zeebe deployment distribution\n[2021-02-23 14:15:06 INFO] Steady-state strategy: default\n[2021-02-23 14:15:06 INFO] Rollbacks strategy: default\n[2021-02-23 14:15:06 INFO] Steady state hypothesis: Zeebe is alive\n[2021-02-23 14:15:06 INFO] Probe: All pods should be ready\n[2021-02-23 14:15:07 INFO] Probe: Should be able to create workflow instances on partition 3\n[2021-02-23 14:15:10 INFO] Steady state hypothesis is met!\n[2021-02-23 14:15:10 INFO] Playing your experiment's method now...\n[2021-02-23 14:15:10 INFO] Action: Create network partition between leaders\n[2021-02-23 14:15:26 INFO] Action: Deploy thousand different deployment versions.\n[2021-02-23 14:15:31 INFO] Action: Delete network partition\n[2021-02-23 14:15:43 INFO] Probe: Create workflow instance of latest version on partition one\n[2021-02-23 14:15:43 INFO] Probe: Create workflow instance of latest version on partition two\n[2021-02-23 14:15:51 INFO] Probe: Create workflow instance of latest version on partition three\n[2021-02-23 14:15:52 INFO] Steady state hypothesis: Zeebe is alive\n[2021-02-23 14:15:52 INFO] Probe: All pods should be ready\n[2021-02-23 14:15:52 INFO] Probe: Should be able to create workflow instances on partition 3\n[2021-02-23 14:15:55 INFO] Steady state hypothesis is met!\n[2021-02-23 14:15:55 INFO] Let's rollback...\n[2021-02-23 14:15:55 INFO] No declared rollbacks, let's move on.\n[2021-02-23 14:15:55 INFO] Experiment ended with status: completed\n"})}),"\n",(0,o.jsx)(n.h4,{id:"testbench",children:"Testbench"}),"\n",(0,o.jsxs)(n.p,{children:["I executed the new experiment via zeebe testbench, to verify that this works with the ",(0,o.jsx)(n.code,{children:"Production - M"})," cluster plan and it was successful ","\ud83d\udcaa"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"operate",src:t(1585).Z+"",width:"1913",height:"918"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{"results":["production-m/deployment-distribution/experiment.json completed successfully","production-m/follower-restart/experiment.json completed successfully","production-m/follower-terminate/experiment.json completed successfully","production-m/leader-restart/experiment.json completed successfully","production-m/leader-terminate/experiment.json completed successfully","production-m/msg-correlation/experiment.json completed successfully","production-m/multiple-leader-restart/experiment.json completed successfully","production-m/snapshot-corruption/experiment.json completed successfully","production-m/stress-cpu-on-broker/experiment.json completed successfully","production-m/worker-restart/experiment.json completed successfully"]}\n'})})]})}function p(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},1585:(e,n,t)=>{t.d(n,{Z:()=>o});const o=t.p+"assets/images/operate-success-6cfd18e98918ee25187b83ca4b925442.png"},11151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>s});var o=t(67294);const i={},r=o.createContext(i);function s(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);